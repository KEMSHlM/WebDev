# about JavaScript
## 1. JavaScriptの歴史
ECMAScriptは，JavaScriptのコアになる仕様である.これは，混在するブラウザ間の互換性を保つために，ECMA Internationalによって標準化されたものである.  
実行環境には，ブラウザ環境とNode.js環境がある.

- ブラウザ環境
    主に，ユーザーの操作に応じて動的に画面を更新するために使用される(**フロントエンド**).  
    ユーザがボタンをクリックしたり，フォームを入力したりする際の動的な応答を担う．  
    ECMAScriptとWeb APIを合わせたものを指す.このWeb APIには，画面の更新を操作するDOM APIや，HTTP通信を行うためのXMLHttpRequest APIなどが含まれる.

- Node.js環境
    JavaScriptをブラウザの外で，サーバーサイドやその他の環境で実行するために開発された．  
    Webサーバーを構築し，データベースとのやりとり，APIの提供，**バックエンド**ロジックの処理を行う．
    ECMAScriptとCommonJSのモジュールを管理する仕組みからなる．  
    
### なぜ二つの環境があるのか？  
    Node.jsの登場により，JavaScripの機能をサーバーサイドに拡張することが可能になった．フロントエンドとバックエンドの両方でJavaScriptを使用することで，一貫した言語での開発が可能になる．
    また，ローカル環境での開発が可能になったことで，開発効率が向上した．  

環境によって使用できる機能が異なるため，ブラウザ環境で使用できる機能とNode.js環境で使用できる機能を区別する必要がある．

## 2. ブラウザの構成
ブラウザは，
- User Interface
- Browser Engine
- Rendering Engine
- Networking
- JavaScript Engine
- UI Backend
- Data Strage
と様々な機能を持つ．

JavaScript Engineは，ChromeではV8というものが使用されている．
JavaScript Engineによって実行結果が異なることがある．

## 3. JavaScript基礎
- グローバルオブジェクト  
    JSエンジンによって生成されるコード内のどこからでもアクセスできるオブジェクト．
    すなわち，JavaScript実行前にはグローバルオブジェクトとthisが準備される．

- コンテキスト  
    実行コンテキストとは，コードを実行する際の文脈，状況を指す.
    それは，コードがどのような状況で実行されているかということ.

- コールスタック  
    コンテキストがスタック構造で管理される．複数階層の関数を呼び出した際に，スクリプト内の位置を追跡し続けることを言う．  
    一番上のスタックは，現在実行中の関数のコンテキストを表す．  
    そして，このスタックは通常実行された順に消滅する．すなわち，一番最後にスタックされたコンテキストが一番最初に消滅する(Last In, First Out)．  
    ?? スタックの積み方で分岐したりするのか？

- ホイスティング  
    コンテキスト内で宣言した変数や関数の定義をコード実行前にメモリーに配置すること．
    すなわち以下のコードでも実行することができる．

    ```js
    a();

    function a() {
        console.log('a is called');
    }
    ```
    
    変数がホイスティングされるかどうかは，宣言方法によって異なる．現在，非推奨であるvarで宣言した変数は，ホイスティングされる．  
    一方，letやconstで宣言した変数は，ホイスティングされない．　

- スコープ  
    スコープには，グローバルスコープとスクリプトスコープがある．
    このスクリプトスコープはグローバルスコープに内包される．

    - レキシカルスコープ(Lexical Scope)
        1. 実行中のコードからみた外部スコープのこと．
        2. どのようにしてそのスコープを決定するかの仕様を指す．

        関数のスコープは，関数が定義された場所によって決まる．
        コードを記述した時点で，決定されるため「静的スコープ」と呼ばれる．
        関数は，自身のスコープより外側のスコープにはアクセスすることができる．　　

        ```js
        // グローバルスコープ
        let a = 2;
        function fn1() {
            // ローカルスコープ(fn1)
            let b = 1;
            // ローカルスコープ(fn2)
            function fn2() {
                let c = 3;
                // クロージャー，スコープチェーン
                console.log(b);
            }
            fn2();
        }
        ```
    
        上の例では，  
        グローバルスコープ(global)はa,  
        ローカルスコープ(fn1)はb, fn2,   
        ローカルスコープ(fn2)はcを持つ．  
        ここで，fn2はglobal, fn1, fn2のスコープにアクセスできる．
        fn1では，global, fn1のスコープにアクセスできる．
        
        すなわちアクセス可能性は，global ⊂　fn1 ⊂ fn2 となる．
        
    - クロージャ  
    外のスコープにある変数を参照する関数のこと． これにより，内部変数を作成したり，動的な関数を作成することができる．  
    
    - 即時関数
    以下のような書き方．

    ```js
    let c = (function (d) {
        console.log("values is " + d);
        return 0;
    })(10)
    ```
    
- 変数について  
再宣言，再代入可能，スコープ，初期化できるかは以下の表にまとめる．  

    | タイプ | 再宣言 | 再代入 | スコープ | 初期化(ホイスティング) | 
    | ---- | ---- | ---- | ---- | ---- |
    | let | x | o | ブロック | x |
    | const | x | x | ブロック | x |
    | var | o | o | 関数 | undefined |

- プリミティブ型とオブジェクト  
    - コピー, 再代入メモリ挙動  
    ~~静的言語やった後に，動的言語やったらバカになるわ.なんやねん.
    当時は難しかったんやろうな．．~~

    以下は，プリミティブ型の挙動
    ```js
    // 以下は，c言語と同じ挙動イメージ．
    let a = 'hello';
    let b = a;

    // ここで，bの値はbが参照していた'hello'はメモリ空間から削除されずに，スコープ等を抜けるまで残る
    // つまり，新たに'Bye'のメモリを確保している．
    b = 'Bye';
    ```
    
    以下は，オブジェクトの挙動
    ```js
    let a = {
        prop: 'hello'
    }
    let b = a;

    // そもそもaは，{...}の参照らしい．だから，bに参照をコピーすることになるから，bを変更するとaも変更される．
    b.prop = 'Bye';
    ```
    
    オブジェクトの完全なコピーはどうするの？
    油断大敵．変なバグを組み込みそう．後の章で具体的な解決策が提示されるのを期待．
    -> 調べてみたらやはり地獄だった．しかも，対応状況はブラウザによって異なる．  
    > [JSにおけるdeepcopy](https://zenn.dev/akkie1030/articles/js-structured-clone)
    
    プリミティブ，オブジェクトともに引数に渡す際も同様な処理がなされる．
    留意する必要があるのは，関数もオブジェクトであるということ．
    
    - 参照とconst
    
    ```js
    const a = {
        prop: 'hello'
    }
    // 以下はできない．
    // a = {};
    
    // しかし，以下はできる．
    a.prop = 'Bye';
    ```

- this
thisは，関数が呼び出された際に，その関数がどのように呼び出されたかによって値が変わる．  
以下の場合，thisはpersonオブジェクトを指す．
```js
const person = {
    name: 'Tom',
    hello: function() {
        console.log('Hello ' + this.name);
    }
}
person.hello();
```

以下の場合，thisはglobalオブジェクトを指す．
```js
window.name = 'John';
const person = {
    name: 'Tom',
    hello: function() {
        console.log('Hello ' + this.name);
    }
}
const ref = person.hello;
ref();
```

つまり，オブジェクトのメソッドとして呼び出された場合は，そのオブジェクトを指す．
一方，関数として呼び出された場合は，globalオブジェクトを指す．

    - bindによる固定  
    上のような状況を回避するにはどうしたら良いのだろうか？

    ```js
    window.name = 'John';

    const person = {
        name: 'Tom',
        hello: function() {
            console.log('Hello ' + this.name);
        }
    }

    // 上を回避するには，bindを使う
    const ref = person.hello.bind(person); // Hello Tom
    ref();
    ```
